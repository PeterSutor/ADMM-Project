% Coded by:     Peter Sutor Jr.
% Last edit:    4/12/2016
% -------------------------------------------------------------------------
% DESCRIPTION -------------------------------------------------------------
%
% Tests the Quadratic Programming problem solver using ADMM. Quadratic 
% Programming minimizes for x the objective function:
%    obj(x) = 1/2*<x,P*x> + <q,x> + r = 1/2*x^T*P*x + q^T*x + r, 
%    subject to D*x = s, x >= 0
% where D is a matrix and s is a column vector of appropriate length. Thus,
% x and b are column vectors of the same length. Matrix P and vector q 
% represent coefficients in the strictly quadratic and strictly linear 
% parts of the program. The value r is a constant. We assume P is a square,
% nonnegative matrix. Note that this formulation is known as the standard 
% form for a quadratic program. One can use any conic constraint on x, not 
% just x >= 0. In this case, one will have to provide the appropriate 
% proximal function for g to minimize this in the options struct 
% (options.altproxg).
%
% Alternatively, we can simplify the constraint in our objective function 
% to be:
%    obj(x) = 1/2*<x,P*x> + <q,x> + r = 1/2*x^T*P*x + q^T*x + r, 
%    subject to lb <= x <= ub
% In this case, lb is a lower bounding vector and ub an upper bounding one.
% We refer to this constraint formulation as 'bounded'. The former
% formulation is referred to as 'standard'.
%
% See function quadraticprogram for more details about how to solve this 
% problem with ADMM.
% 
% For the standard constraint:
% The test creates random data for P, D, b and s, of size rows by cols,
% given as inputs. The seed specifies the seed value to use in random number 
% generation, for repeatability. The value errtol is the relative error 
% tolerance from the 'true' solution that is allowed for the test to be
% successful. The variable quiet determines whether to suppress output and
% graphs.
%
% Consult the user manual for instructions and examples on how to set the
% options argument to customize the solver.
%
% NOTE: If quadraticprogramtest is executed with no arguments, it will
% a demo test of random data of size m = 2^6, n = 2^7. The random values
% are generated by the function rng with the 'shuffle' option to be 
% seedless. The rows and cols are set to m and n, with an errtol of 0.001,
% and quiet = 0. The options struct is set to empty, thus using ADMM's 
% default setup.

function [results, test] = ...
    quadraticprogramtest(seed, rows, cols, errtol, quiet, options)
% INPUTS ------------------------------------------------------------------
% seed:     The seed used to generate random data in the test.
% rows:     The variable m in the m by n problem specified in the problem
%           being tested, described in the description above. Used only in
%           generating data for D in standard form, as number of rows in D.
% cols:     The variable n in the m by n problem specified in the problem
%           being tested, described in the description above. Specifies the
%           size of square matrix P and vector q. In standard form, it is
%           also the number of columns in D.
% errtol:   The relative error from the 'true' solution that is allowed for
%           the test to be considered successfully convergent. Typical
%           values are 0.01 or 0.001, corresponding to 1% or 0.1% accuracy
%           to the true solution.
% quiet:    A binary value specifying whether to show output and graphs for
%           the test.
% options:  A struct containing options customizing the ADMM execution. If
%           no options are provided (an empty or irrelevant struct is given
%           as the options parameter), default settings are applied, as 
%           mentioned in the user manual.
% 
% OUTPUTS -----------------------------------------------------------------
% results:  A struct containing the results of the execution, including the
%           optimized values for x, z and u that optimize the objective for
%           x, runtime evaluations, records of each iteration, etc. Consult
%           the user manual for more details on the results struct, or
%           simply check what the variable contains in the Matlab 
%           interpreter after execution. This testing function will test
%           both constraint types and return their individual results in
%           the results struct as results.standard and results.bounded.
% test:     A struct containing the details of the random test that was
%           performed, including the random data generated, how correct it
%           was, whether it reached the correct tolerance (successful test)
%           and so on. Consult the user manual for more details on the test
%           struct, or simply check what the variable contains in the 
%           Matlab interpreter after execution. This testing function will
%           test both constraint types and return their individual test
%           details in the test struct as test.standard and test.bounded.
% -------------------------------------------------------------------------


% Persistent global variable to indicate whether paths have been set or
% not.
global setup;

% Check if paths need to be set up.
if isempty(setup)
    currpath = pwd;                         % Save current directory.
    
    % Get directory of this function (assumed to be in testers folder of 
    % ADMM library).
    filepath = mfilename('fullpath');       % Get current file path.
    filepath = filepath(1:length(filepath) - length(mfilename()));
    
    % Switch to directory containing setuppaths and run it. Then switch
    % back to original directory. Save setup = 1 to indicate to all other
    % functions that setup has already been done.
    cd(filepath);
    cd('..');
    setuppaths(1);
    cd(currpath);
    setup = 1;
end

% Check if no arguments were given. If so, run the default test, otherwise
% proceed with user's inputs.
if nargin == 0
    % Demo test's default settings.
    rng('shuffle');
    rows = 2^6;
    cols = 2^7;
    errtol = 0.001;
    quiet = 0;
    options = struct();
else
    % Error checking on input.
    [seed, rows, cols, errtol, quiet] = ...
        errorcheck(seed, rows, cols, errtol, quiet, options);

    rng('default');             % Default RNG.
    rng(seed);                  % Seed the RNG.
end

% Generate a random quadratic coefficient matrix P, as a well-conditioned,
% positive definite matrix (gives fast convergence).
P = rand(cols);
P = P + P';
[V, ~] = eig(P);
P = V*diag(1 + rand(cols, 1))*V';

% Create random data and random solution to solve for using ADMM, for both
% constraint types.
q = randn(cols, 1);             % Normally distributed random linear 
                                % coefficients.
r = randn(1);                   % Random constant r in objective.

truex = abs(randn(cols, 1));    % Create a random true optimal x.
D = abs(randn(rows, cols));     % Normally random D matrix.
s = D*truex;                    % The value s would have to be.
trueobjopt = q'*truex;          % True solution's objective value.

% Random upper and lower bounds.
l = randn(cols,1);
u = randn(cols,1);
lb = min(l,u);
ub = max(l,u);

% Set the options struct for ADMM.
options.objevals = 1;
options.maxiters = 1000;
options.solver = 'quadraticprogram';

% Run the Quadratic Program solver for random data and retrieve solution.
results = quadraticprogram(P, q, r, lb, ub, options);

% Obtain relevant data from ADMM solution.
xopt = results.xopt;            % ADMM's optimal x solution.
admmopt = results.objopt;       % ADMM's optimal objective value.
objopt = q'*xopt;               % The actual objective value computed.

% Compute the average relative error from true solution (D*xopt - s should 
% be close to 0), relative to s.
relerror = norm(D*xopt - s, 'fro');

% Check to see if the test was successful or not (within error tolerance).
if (abs(trueobjopt - objopt) <= errtol*objopt && relerror <= errtol)
    failed = 0;
else
    failed = 1;
end

% Populate the test struct with details about the test and its results.
test.q = q;
test.D = D;
test.s = s;
test.truexopt = truex;
test.trueobjopt = trueobjopt;
test.xopt = xopt;
test.admmopt = admmopt;
test.objopt = objopt;
test.failed = failed;
test.constraintresidual = norm(D*xopt - s, 'fro');  % Constraint residual.
test.xresidual = norm(truex - xopt, 'fro');         % Residual in x values.
test.steps = results.steps;                         % Number of iterations.
test.errtol = errtol;

% Show results if the user wanted to see them. 
if ~quiet
    showresults(results, test, options);
end

end
% -------------------------------------------------------------------------



% -------------------------------------------------------------------------
% DESCRIPTION -------------------------------------------------------------
% 
% Simply checks for any user error on same input, stops if error is
% detected. If input is correct, return info needed for problem.

function [seed, rows, cols, errtol, quiet] = ...
    errorcheck(seed, rows, cols, errtol, quiet, options)
% INPUTS ------------------------------------------------------------------
% Same as for the linearprogramtest function.
% 
% OUTPUTS -----------------------------------------------------------------
% Same as the inputs, just potentially altered values for strange input.
% -------------------------------------------------------------------------


% Check for invalid input and report errors / terminate if detected.
if (~isnumeric(seed) || floor(seed) < 0)
    error('Given RNG seed is not a nonnegative integer!');
elseif (~isnumeric(rows) || floor(real(rows)) < 0)
    error('Given number of rows is not a nonnegative integer!');
elseif (~isnumeric(cols) || floor(real(cols)) < 0)
    error('Given number of columns is not a nonnegative integer!');
elseif (~isnumeric(errtol) || real(errtol) <= 0)
    error('Given error tolerance errtol is not a positive number!');
else
    seed = floor(real(seed));   % Set the seed to valid value.
    rows = floor(real(rows));   % Set the rows to valid value.
    cols = floor(real(cols));   % Set the columnss to valid value.
    errtol = real(errtol);      % Set error tolerance to valid value.
end

% Only set output to be suppressed if specified.
if (~isnumeric(quiet) || floor(real(quiet)) ~= 1)
    quiet = 0;
else
    quiet = 1;
end

% Check that the given options is actually a struct...
if ~isstruct(options)
    error('Given options is not a struct! At least pass empty struct!');
end

end
% -------------------------------------------------------------------------