% Coded by:     Peter Sutor Jr.
% Last edit:    4/12/2016
% -------------------------------------------------------------------------
% DESCRIPTION -------------------------------------------------------------
%
% Tests the Total Variation Minimization solver using ADMM. TVM 
% minimizes for x the objective function:
%    obj(x) = 1/2||x - s||_2^2 + lambda*sum_i{|x_{i+1} - x_i|}, 
% where x and s are column vectors of length m. The vector s is a given 
% vector of signals to perform TVM on. The minimized vector x is a denoised
% version of s in the sense of total variation. The constant lambda 
% represents how strictly or loosely to minimize the noise in s. See 
% function totalvariation for more details about how to solve this problem
% with ADMM.
% 
% The test creates random data for noisy data signal s, of size rows, given
% as input. The seed specifies the seed value to use in random number 
% generation, for repeatability. The value errtol is the relative error 
% tolerance from the 'true' solution that is allowed for the test to be
% successful. The variable quiet determines whether to suppress output and
% graphs.
%
% Consult the user manual for instructions and examples on how to set the
% options argument to customize the solver.
%
% NOTE: If totalvariationtest is executed with no arguments, it will create
% a demo test of random data of size rows = n = 2^7. The random values are
% generated by the function rng with the 'shuffle' option to be seedless.
% The rows and cols of D and I are set to n, and quiet = 0. The options 
% struct is set to empty, thus using ADMM's default setup.
%
% Lambda is by default set to 1.0. If you wish to change this value, set it
% in the options struct; i.e., options.lambda = lambdavalue.

function [results, test] = ...
    totalvariationtest(seed, rows, errtol, quiet, options)
% INPUTS ------------------------------------------------------------------
% seed:     The seed used to generate random data in the test.
% rows:     The length of noisy vector s.
% errtol:   The relative error from the 'true' solution that is allowed for
%           the test to be considered successfully convergent. Typical
%           values are 0.01 or 0.001, corresponding to 1% or 0.1% accuracy
%           to the true solution.
% quiet:    A binary value specifying whether to show output and graphs for
%           the test.
% options:  A struct containing options customizing the ADMM execution. If
%           no options are provided (an empty or irrelevant struct is given
%           as the options parameter), default settings are applied, as 
%           mentioned in the user manual.
% 
% OUTPUTS -----------------------------------------------------------------
% results:  A struct containing the results of the execution, including the
%           optimized values for x, z and u that optimize the objective for
%           x, runtime evaluations, records of each iteration, etc. Consult
%           the user manual for more details on the results struct, or
%           simply check what the variable contains in the Matlab 
%           interpreter after execution.
% test:     A struct containing the details of the random test that was
%           performed, including the random data generated, how correct it
%           was, whether it reached the correct tolerance (successful test)
%           and so on. Consult the user manual for more details on the test
%           struct, or simply check what the variable contains in the 
%           Matlab interpreter after execution.
% -------------------------------------------------------------------------


% Persistent global variable to indicate whether paths have been set or
% not.
global setup;

% Check if paths need to be set up.
if isempty(setup)
    currpath = pwd;                         % Save current directory.
    
    % Get directory of this function (assumed to be in testers folder of 
    % ADMM library).
    filepath = mfilename('fullpath');       % Get current file path.
    filepath = filepath(1:length(filepath) - length(mfilename()));
    
    % Switch to directory containing setuppaths and run it. Then switch
    % back to original directory. Save setup = 1 to indicate to all other
    % functions that setup has already been done.
    cd(filepath);
    cd('..');
    setuppaths(1);
    cd(currpath);
    setup = 1;
end

% Check if no arguments were given. If so, run the default test, otherwise
% proceed with user's inputs.
if nargin == 0
    % Demo test's default settings.
    rng('shuffle');
    rows = 2^7;
    errtol = 0.02;
    quiet = 0;
    lambda = 1.0;
    options = struct();
else
    % Error checking on input.
    [seed, rows, errtol, quiet, lambda] = ...
        errorcheck(seed, rows, errtol, quiet, options);

    rng('default');             % Default RNG.
    rng(seed);                  % Seed the RNG.
end

truexopt = ones(rows, 1);       % Vector to store sampling.

% Purpose: Populate truexopt with random data. Perform n/10 repetitions of
% random data population in continuous subsets of whole signal.
for k = 1:ceil(3)

    rs = randsample(rows, 1);   % Random integer from 1 to n.
    ri = randsample(1:10, 1);   % Random integer from 1 to 10.

    % Multiply randomly selected continuous segments in components from
    % ceiling(rs/2) up to rs by random integer ri. Should a layered signal.
    truexopt(ceil(rs/2):rs) = ri*truexopt(ceil(rs/2):rs);

end

% Add small, random perturbations to our true signal truexopt. This is the
% noise we smooth over. ADMM should hopefully produce something similar to
% truexopt, given s.
s = truexopt + randn(rows, 1);

% Set the options struct for ADMM.
options.objevals = 1;
options.maxiters = 10000;
options.tester = 'totalvariation';

% The objective function for TVM.
objective = @(x) 1/2*norm(x - s, 'fro')^2 + ...
    lambda*sum(abs(x(2:length(x)) - x(1:length(x)-1)));

% The true, optimal, objective value.
trueobjopt = objective(truexopt);

% Perform the Total Variation Minimization on our signal s, with strictness
% lambda.
results = totalvariation(s, lambda, options);

% Obtain relevant data from ADMM solution.
xopt = results.xopt;                % ADMM's optimal x solution.
admmopt = results.objopt;           % ADMM's optimal objective value.
objopt = objective(xopt);           % The actual objective value computed.

% Check to see if the test was successful or not.
if (objopt < trueobjopt)
    failed = 0;
else
    failed = 1;
end

% Populate the test struct with details about the test and its results.
test.s = s;
test.truexopt = truexopt;
test.trueobjopt = trueobjopt;
test.xopt = xopt;
test.admmopt = admmopt;
test.objopt = objopt;
test.failed = failed;
test.relerror = abs((trueobjopt - objopt)/objopt);
test.steps = results.steps;
test.errtol = errtol;

% Show results if the user wanted to see them. 
if ~quiet
    % Run show results on output.
    showresults(results, test, options);

    % Show denoised signal for Total Variation.
    figure;
    plot(1:length(s), s, 'k', 1:length(xopt), xopt, 'r', 'LineWidth', 2);
    title(['Noisy Signal vs. TVM Denoised Signal: lambda = ', ...
        num2str(lambda)]);
    legend('Original Signal', 'Denoised Signal');
    ylabel('Signal'); 
end

end
% -------------------------------------------------------------------------



% -------------------------------------------------------------------------
% DESCRIPTION -------------------------------------------------------------
% 
% Simply checks for any user error on same input, stops if error is
% detected. If input is correct, return info needed for problem.

function [seed, rows, errtol, quiet, lambda] = ...
    errorcheck(seed, rows, errtol, quiet, options)
% INPUTS ------------------------------------------------------------------
% Same as for the totalvariationtest function.
% 
% OUTPUTS -----------------------------------------------------------------
% Same as the inputs, just potentially altered values for strange input.
% -------------------------------------------------------------------------


% Check for invalid input and report errors / terminate if detected.
if (~isnumeric(seed) || floor(seed) < 0)
    error('Given RNG seed is not a nonnegative integer!');
elseif (~isnumeric(rows) || floor(real(rows)) < 0)
    error('Given number of rows is not a nonnegative integer!');
elseif (~isnumeric(errtol) || real(errtol) <= 0)
    error('Given error tolerance errtol is not a positive number!');
else
    seed = floor(real(seed));   % Set the seed to valid value.
    rows = floor(real(rows));   % Set the rows to valid value.
    errtol = real(errtol);      % Set error tolerance to valid value.
end

% Only set output to be suppressed if specified.
if (~isnumeric(quiet) || floor(real(quiet)) ~= 1)
    quiet = 0;
else
    quiet = 1;
end

% Check that the given options is actually a struct...
if ~isstruct(options)
    error('Given options is not a struct! At least pass empty struct!');
end

% If the user provided a lambda value to use, use it. Otherwise, set to 1.0
% as default.
if isfield(options, 'lambda')
    lambda = options.lambda;
    
    % Report if there are any issues with the regularization parameter.
    if (~isnumeric(lambda) || real(lambda) < 0)
        error('Given strictness parameter lambda is an invalid value!');
    else
        lambda = real(lambda);
    end
else
    lambda = 1.0;
end

end
% -------------------------------------------------------------------------